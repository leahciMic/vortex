import parse;
import Number;

// TODO: {a, b, ...} := rhs
Many := parse.Many;
Select := parse.Select;

Program := Many(Select([
  Number,
  Whitespace,
  Fail,
]));

func Whitespace(lines, [i, j]) {
  empty := true;

  if (i >= lines:Length()) {
    return null;
  }

  line := lines[i];

  for {
    for (j >= line:Length()) {
      empty = false;
      i++;
      j = 0u64;

      if (i >= lines:Length()) {
        return [['whitespace'], [i, j]];
      }

      line = lines[i];
    }

    if (!isWhitespace(line[j])) {
      return switch (empty) {
        true => null;
        false => [['whitespace'], [i, j]];
      };
    }

    empty = false;
    j++;
  }
};

func Fail(lines, [i, j]) {
  if (i >= lines:Length()) {
    return null;
  }

  line := lines[i];

  if (j < line:Length()) {
    j++;

    if (j == line:Length()) {
      i++;
      j = 0u64;
    }

    return ['fail', [i, j]];
  }

  i++;
  j = 0u64;

  return ['fail', [i, j]];
};

func isWhitespace(s) => switch {
  (s == ' ') => true;
  (s == '	') => true; // TODO: \t escape sequence (and others)

  true => false;
};

sampleLines := [
  '123 ',
  '',
  ' ',
  '  321 ',
];

assert Program(sampleLines, [0u64, 0u64]):Front() == [
  {data: ['literal', 123u64], pos: [[0u64, 0u64], [0u64, 3u64]]},
  {data: ['whitespace'], pos: [[0u64, 3u64], [3u64, 2u64]]},
  {data: ['literal', 321u64], pos: [[3u64, 2u64], [3u64, 5u64]]},
  {data: ['whitespace'], pos: [[3u64, 5u64], [4u64, 0u64]]},
];

return Program;
