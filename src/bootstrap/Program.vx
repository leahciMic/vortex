import parse;

// TODO: {a, b, ...} := rhs
Many := parse.Many;
Select := parse.Select;

Program := Many(Select([
  Number,
  Whitespace,
  Fail,
]));

func Digit(s) => switch {
  (s == '0') => 0u64;
  (s == '1') => 1u64;
  (s == '2') => 2u64;
  (s == '3') => 3u64;
  (s == '4') => 4u64;
  (s == '5') => 5u64;
  (s == '6') => 6u64;
  (s == '7') => 7u64;
  (s == '8') => 8u64;
  (s == '9') => 9u64;

  true => null;
};

func Number(lines, [i, j]) {
  line := NonEmptyLine(lines, [i, j]);

  if (isNull(line)) {
    return null;
  }

  res := null;

  for {
    digit := Digit(line[j]);

    if (isNull(digit)) {
      break;
    }

    if (isNull(res)) {
      res = digit;
    } else {
      res *= 10u64;
      res += digit;
    }

    j++;

    if (j >= line:Length()) {
      break;
    }
  }

  if (isNull(res)) {
    return null;
  }

  return [['literal', res], [i, j]];
};

func Whitespace(lines, [i, j]) {
  empty := true;

  if (i >= lines:Length()) {
    return null;
  }

  line := lines[i];

  for {
    for (j >= line:Length()) {
      empty = false;
      i++;
      j = 0u64;

      if (i >= lines:Length()) {
        return [['whitespace'], [i, j]];
      }

      line = lines[i];
    }

    if (!isWhitespace(line[j])) {
      return switch (empty) {
        true => null;
        false => [['whitespace'], [i, j]];
      };
    }

    empty = false;
    j++;
  }
};

func Fail(lines, [i, j]) {
  if (i >= lines:Length()) {
    return null;
  }

  line := lines[i];

  if (j < line:Length()) {
    j++;

    if (j == line:Length()) {
      i++;
      j = 0u64;
    }

    return ['fail', [i, j]];
  }

  i++;
  j = 0u64;

  return ['fail', [i, j]];
};

func isWhitespace(s) => switch {
  (s == ' ') => true;
  (s == '	') => true; // TODO: \t escape sequence (and others)

  true => false;
};

func NonEmptyLine(lines, [i, j]) {
  if (i >= lines:Length()) {
    return null;
  }

  line := lines[i];

  if (j >= line:Length()) {
    return null;
  }

  return line;
};

func isNull(x) => x:String() == 'null';

sampleLines := [
  '123 ',
  '',
  ' ',
  '  321 ',
];

assert Program(sampleLines, [0u64, 0u64]):Front() == [
  {data: ['literal', 123u64], pos: [[0u64, 0u64], [0u64, 3u64]]},
  {data: ['whitespace'], pos: [[0u64, 3u64], [3u64, 2u64]]},
  {data: ['literal', 321u64], pos: [[3u64, 2u64], [3u64, 5u64]]},
  {data: ['whitespace'], pos: [[3u64, 5u64], [4u64, 0u64]]},
];

return Program;
